'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs-extra'));
var globby = _interopDefault(require('globby'));
var ware = _interopDefault(require('ware'));

function __async(g){return new Promise(function(s,j){function c(a,x){try{var r=g[x?"throw":"next"](a);}catch(e){j(e);return}r.done?s(r.value):Promise.resolve(r.value).then(c,d);}function d(e){c(e,1);}c();})}

class Majo {
  constructor() {
    this.middlewares = [];
    this.meta = {};
  }

  source(source, ref) {
    if ( ref === void 0 ) ref = {};
    var baseDir = ref.baseDir; if ( baseDir === void 0 ) baseDir = '.';
    var dotFiles = ref.dotFiles; if ( dotFiles === void 0 ) dotFiles = true;

    this.baseDir = path.resolve(baseDir);
    this.sourcePatterns = source;
    this.dotFiles = dotFiles;
    return this
  }

  use(middleware) {
    this.middlewares.push(middleware);
    return this
  }

  process() {return __async(function*(){
    const statCache = {};
    const paths = yield globby(this.sourcePatterns, {
      nodir: true,
      cwd: this.baseDir,
      dot: this.dotFiles,
      statCache
    });

    this.files = {};

    yield Promise.all(paths.map(relative => {
      const absolutePath = path.resolve(this.baseDir, relative);
      return fs.readFile(absolutePath)
        .then(contents => {
          const stats = statCache[path.isAbsolute(this.baseDir) ? absolutePath : relative];
          const file = { contents, stats, path: absolutePath };
          this.files[relative] = file;
        })
    }));

    yield new Promise((resolve, reject) => {
      ware().use(this.middlewares).run(this, err => {
        if (err) { return reject(err) }
        resolve();
      });
    });

    return this.files
  }.call(this))}

  filter(fn) {
    return this.use(context => {
      for (const relative in context.files) {
        if (!fn(relative, context.files[relative])) {
          delete context.files[relative];
        }
      }
    })
  }

  transform(relative, fn) {
    const contents = this.files[relative].contents.toString();
    const result = fn(contents);
    if (!result.then) {
      this.files[relative].contents = Buffer.from(result);
      return
    }
    return result.then(newContents => {
      this.files[relative].contents = Buffer.from(newContents);
    })
  }

  dest(dest, ref) {
  if ( ref === void 0 ) ref = {};
  var baseDir = ref.baseDir; if ( baseDir === void 0 ) baseDir = '.';
  var clean = ref.clean;
return __async(function*(){
    const destPath = path.resolve(baseDir, dest);
    const files = yield this.process();

    if (clean) {
      yield fs.remove(destPath);
    }

    yield Promise.all(Object.keys(files).map(filename => {
      var ref = files[filename];
      var contents = ref.contents;
      const target = path.join(destPath, filename);
      return fs.ensureDir(path.dirname(target))
        .then(() => fs.writeFile(target, contents))
    }));
  }.call(this))}

  fileContents(relative) {
    return this.file(relative).contents.toString()
  }

  writeContents(relative, string) {
    this.files[relative].contents = Buffer.from(string);
    return this
  }

  fileStats(relative) {
    return this.file(relative).stats
  }

  file(relative) {
    return this.files[relative]
  }

  deleteFile(relative) {
    delete this.files[relative];
    return this
  }

  createFile(relative, file) {
    this.files[relative] = file;
    return this
  }

  get fileList() {
    return Object.keys(this.files).sort()
  }
}

var index = opts => new Majo(opts);

module.exports = index;
